--- Lösung nach Iteration 1 ---

package de.mwolff.fourwins.model;

public class FourWinModel {

	private static final int column = 7;
	private static final int row = 6;
	private static char[][] field = new char[row][column];
	
	static {
		for (int rowCount = 0; rowCount < row; rowCount ++) {
			for (int columnCount = 0; columnCount < column; columnCount++) {
				field[rowCount][columnCount] = '*';
			}
		}
	}
	
	public void setCoin(char color, int column) {
		field[0][ column - 1] = color;

	}

	public boolean isCoin(char color, int row, int column) {
		return field[row - 1][column - 1]  == color;
	}

}

--- Lösung nach Test 2 ---

package de.mwolff.fourwins.model;

public class FourWinModel {

	private static final int column = 7;
	private static final int row = 6;
	private static char[][] field = new char[row][column];

	static {
		for (int rowCount = 0; rowCount < row; rowCount++) {
			for (int columnCount = 0; columnCount < column; columnCount++) {
				field[rowCount][columnCount] = '*';
			}
		}
	}

	public void setCoin(char color, int column) {
		int row = getNextRowEmpty(column);
		setField(color, column, row);
	}


	public boolean isCoin(char color, int row, int column) {
		return field[row - 1][column - 1] == color;
	}

	private void setField(char color, int column, int row) {
		field[row][column - 1] = color;
	}

	private int getNextRowEmpty(int column) {
		int i = 0;
		while (i < row) {
			if (field[i][column - 1] == '*')
				break;
			i++;
		}
		return i;
	}
}

--- Lösung nach Iteration 3 ---
package de.mwolff.fourwins.model;

public class FourWinModel {

	public static final int column = 7;
	public static final int row = 6;
	private char[][] field = new char[row][column];

	private int lastrow = -1;

	public FourWinModel() {
		for (int rowCount = 0; rowCount < row; rowCount++) {
			for (int columnCount = 0; columnCount < column; columnCount++) {
				field[rowCount][columnCount] = '*';
			}
		}
	}

	public void setCoin(char color, int column) {
		int row = getNextRowEmpty(column);
		setField(color, column, row);
	}

	public boolean isCoin(char color, int row, int column) {
		return field[row - 1][column - 1] == color;
	}

	private void setField(char color, int column, int row) {
		field[row][column - 1] = color;
		lastrow = row;
	}

	private int getNextRowEmpty(int column) {
		int i = 0;
		while (i < row) {
			if (field[i][column - 1] == '*')
				break;
			i++;
		}
		return i;
	}

	public boolean isWin() {

		char currentField = '_';
		int zaehler = 0;
		for (int i = 0; i < column; i++) {
			char current = field[lastrow][i];
			if ((current == currentField) && (current != '*')) {
				zaehler++;
			} else if ((current != currentField) && (current != '*')) {
				zaehler = 1;
			}
			currentField = current;
		}

		return zaehler >= 4;
	}

	public int getLastRow() {
		return lastrow;
	}

	public char getColor(int row, int column) {
		return field[row][column];
	}
}

package de.mwolff.fourwins.model;

public class WinStrategy {
	
	FourWinModel model;

	public WinStrategy(FourWinModel model) {
		this.model = model;
	}

	public boolean isWin() {
		
		return isHorizontalWin();
	}

	private boolean isHorizontalWin() {
		char currentField = '_';
		int zaehler = 0;
		for (int column = 0; column < FourWinModel.column; column++) {
			char current = model.getColor(model.getLastRow(), column);
			if ((current == currentField) && (current != '*')) {
				zaehler++;
			} else if ((current != currentField) && (current != '*')) {
				zaehler = 1;
			}
			currentField = current;
		}

		return zaehler >= 4;
	}

}
}

--- Lösung nach Iteration 4 ---

package de.mwolff.fourwins.model;

public class WinStrategy {

	FourWinModel model;

	public WinStrategy(FourWinModel model) {
		this.model = model;
	}

	public boolean isWin() {
		if (isHorizontalWin())
			return true;
		if (isVerticalWin())
			return true;
		return false;
	}

	private boolean isVerticalWin() {
		char currentField = '_';
		int zaehler = 0;
		for (int row = 0; row < FourWinModel.row; row++) {
			char current = model.getColor(row, model.getLastColumn());
			zaehler = setCorrectCounter(currentField, zaehler, current);
			currentField = current;
		}
		return strategyWins(zaehler);
	}

	private boolean isHorizontalWin() {
		char currentField = '_';
		int zaehler = 0;
		for (int column = 0; column < FourWinModel.column; column++) {
			char current = model.getColor(model.getLastRow(), column);
			zaehler = setCorrectCounter(currentField, zaehler, current);
			currentField = current;
		}

		return strategyWins(zaehler);
	}

	private boolean strategyWins(int zaehler) {
		return zaehler >= 4;
	}

	private int setCorrectCounter(char currentField, int zaehler, char current) {
		if ((current == currentField) && (current != '*')) {
			zaehler++;
		} else if ((current != currentField) && (current != '*')) {
			zaehler = 1;
		}
		return zaehler;
	}
}

--- Lösung nach Iteration 5 ---

package de.mwolff.fourwins.model;

public class WinStrategy {

	FourWinModel model;

	public WinStrategy(FourWinModel model) {
		this.model = model;
	}

	public char isWin() {
		if (isHorizontalWin() || isVerticalWin() || isDiagonalRightLeftWin()
				|| isDiagonalLeFtRightWin())
			return model.getLastColor();
		return '*';
	}

	private boolean isDiagonalRightLeftWin() {

		// Find left begin
		int coinRow = model.getLastRow();
		int coinColumn = model.getLastColumn();

		try {
			for (;;) {
				coinRow--;
				coinColumn++;
				model.getColor(coinRow, coinColumn);
				if ((coinRow == 0) || (coinColumn == FourWinModel.column)) {
					break;
				}
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			// End of row
		}

		// count same color
		char currentField = '_';
		int zaehler = 0;
		try {
			for (;;) {
				char current = model.getColor(coinRow++, coinColumn--);
				zaehler = setCorrectCounter(currentField, zaehler, current);
				currentField = current;
				if (zaehler == 4)
					break;
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			// End of row
		}

		return strategyWins(zaehler);
	}

	private boolean isDiagonalLeFtRightWin() {

		// Find left begin
		int coinRow = model.getLastRow();
		int coinColumn = model.getLastColumn();

		try {
			for (;;) {
				coinRow--;
				coinColumn--;
				model.getColor(coinRow, coinColumn);
				if ((coinRow == 0) || (coinColumn == 0)) {
					break;
				}
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			//
		}

		// count same color
		char currentField = '_';
		int zaehler = 0;
		try {
			for (;;) {
				char current = model.getColor(coinRow++, coinColumn++);
				zaehler = setCorrectCounter(currentField, zaehler, current);
				currentField = current;
				if (zaehler == 4)
					break;
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			// End of row
		}

		return strategyWins(zaehler);
	}

	private boolean isVerticalWin() {
		char currentField = '_';
		int zaehler = 0;
		for (int row = 0; row < FourWinModel.row; row++) {
			char current = model.getColor(row, model.getLastColumn());
			zaehler = setCorrectCounter(currentField, zaehler, current);
			currentField = current;
		}
		return strategyWins(zaehler);
	}

	private boolean isHorizontalWin() {
		char currentField = '_';
		int zaehler = 0;
		for (int column = 0; column < FourWinModel.column; column++) {
			char current = model.getColor(model.getLastRow(), column);
			zaehler = setCorrectCounter(currentField, zaehler, current);
			currentField = current;
		}

		return strategyWins(zaehler);
	}

	private boolean strategyWins(int zaehler) {
		return zaehler >= 4;
	}

	private int setCorrectCounter(char currentField, int zaehler, char current) {
		if ((current == currentField) && (current != '*')) {
			zaehler++;
		} else if ((current != currentField) && (current != '*')) {
			zaehler = 1;
		}
		return zaehler;
	}
}

